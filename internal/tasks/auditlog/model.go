package auditlog

import (
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/hex"
	"time"

	"github.com/Laisky/errors/v2"
	gcrypto "github.com/Laisky/go-utils/v4/crypto"
	"github.com/Laisky/laisky-blog-graphql/library/db/mongo"
	"github.com/Laisky/zap"
	"go.mongodb.org/mongo-driver/bson/primitive"
	mongoLib "go.mongodb.org/mongo-driver/mongo"

	"github.com/Laisky/go-ramjet/library/log"
)

// Log for audit log
//
// # Example
//
//		{
//			"level": "info",
//			"time": "2023-08-01T09:09:34.377Z",
//			"logger": "pki.pki-audit",
//			"caller": "audit/log.go:61",
//			"msg": "yahoo",
//			"cluster_uuid": "63760a3b-2f53-11ee-b5a4-5c6f69c1c020",
//			"uuid": "63760a3b-2f53-11ee-b5a4-5c6f69c1c123",
//			"ts": "2023-08-01T09:09:28Z",
//			"cert_chain": "-----BEGIN CERTIFICATE-xxx",
//	        "signature": "3282c1160a47c84xxx"
//		}
type Log struct {
	ID          primitive.ObjectID `bson:"_id" json:"-"`
	Level       string             `bson:"level" json:"level"`
	Time        time.Time          `bson:"time" json:"time"`
	Logger      string             `bson:"logger" json:"logger"`
	Caller      string             `bson:"caller" json:"caller"`
	Msg         string             `bson:"msg" json:"msg"`
	ClusterUUID string             `bson:"cluster_uuid" json:"cluster_uuid"`
	// Ts used for generate signature
	Ts        string `bson:"ts" json:"ts"`
	CertChain string `bson:"cert_chain" json:"cert_chain"`
	// Signature generated by RSASHA256(msg + l.clusterUUID + ts)
	Signature string `bson:"signature" json:"signature"`
	UUID      string `bson:"uuid" json:"uuid"`
}

// Valid check log
func (l *Log) Valid(rootcaPool *x509.CertPool) (err error) {
	// check signature
	{
		certs, err := gcrypto.Pem2Certs([]byte(l.CertChain))
		if err != nil {
			return errors.Wrap(err, "try to parse cert chain")
		}

		if rootcaPool != nil {
			intermedia := x509.NewCertPool()
			for _, cert := range certs[1:] {
				intermedia.AddCert(cert)
			}

			if _, err = certs[0].Verify(x509.VerifyOptions{
				Roots:         rootcaPool,
				Intermediates: intermedia,
			}); err != nil {
				return errors.Wrap(err, "verify cert chain by rootca")
			}
		}

		pubkey, ok := certs[0].PublicKey.(*rsa.PublicKey)
		if !ok {
			return errors.New("pubkey must be *rsa.PublicKey")
		}

		sig, err := hex.DecodeString(l.Signature)
		if err != nil {
			return errors.Wrap(err, "try to decode signature")
		}

		if err = gcrypto.VerifyByRSAWithSHA256(
			pubkey,
			[]byte(l.Ts+l.Msg+l.ClusterUUID+l.UUID),
			sig,
		); err != nil {
			return errors.Wrap(err, "verify signature")
		}
	}

	return nil
}

// AuditDB audit db
type AuditDB struct {
	db                 mongo.DB
	dbName, logColName string
}

// NewDB new db
func NewDB(ctx context.Context, addr, dbName, user, pwd, logColName string) (b *AuditDB, err error) {
	log.Logger.Info("connect to db",
		zap.String("user", user),
		zap.String("addr", addr),
		zap.String("dbName", dbName),
		zap.String("logColName", logColName),
	)
	b = &AuditDB{
		dbName:     dbName,
		logColName: logColName,
	}
	b.db, err = mongo.NewDB(ctx, mongo.DialInfo{
		Addr:   addr,
		DBName: dbName,
		User:   user,
		Pwd:    pwd,
	})
	if err != nil {
		return nil, errors.Wrapf(err, "try to connect to db %s", addr)
	}

	return b, nil
}

func (b *AuditDB) logCol() *mongoLib.Collection {
	return b.db.DB(b.dbName).Collection(b.logColName)
}

// Close close db connection
func (b *AuditDB) Close(ctx context.Context) {
	_ = b.db.Close(ctx)
}
